
Source Cogol:
# recursively calculate the 10th Fibonacci number
call display = fib(10).sum;
sub fib(cur,sum){
  if(cur <= 2){
    sum = 1;
    return;
  }
  cur--;
  call sum = fib(cur).sum;
  cur--;
  call sum += fib(cur).sum;
}

Tokens:
[call, display, =, fib, (, 10, ), ., sum, ;, sub, fib, (, cur, ,, sum, ), {, if, (, cur, <=, 2, ), {, sum, =, 1, ;, return, ;, }, cur, --, ;, call, sum, =, fib, (, cur, ), ., sum, ;, cur, --, ;, call, sum, +=, fib, (, cur, ), ., sum, ;, }]

Compiled QFTASM:
0. MLZ -1 8 7; preloadCallStack
1. ADD A7 1 4;
2. MLZ -1 A3 A4;
3. MLZ -1 A7 2;
4. ADD A2 2 4;
5. MLZ -1 10 A4;
6. MLZ -1 A2 3;
7. MLZ -1 10 A3;
8. MLZ -1 14 0;
9. ADD A3 4 7; call4_fib
10. ADD A7 3 2;
11. MLZ -1 B2 1;
12. MLZ -1 58 0;
13. MLZ 0 0 0; beginSub0_fib
14. ADD A3 2 2;
15. SUB 2 B2 2;
16. MLZ A2 24 0; beginIf1
17. MLZ 0 0 0;
18. ADD A3 3 2;
19. MLZ -1 1 A2;
20. MLZ -1 A3 7;
21. ADD A3 1 2;
22. MLZ -1 B3 0;
23. MLZ -1 B2 3; return endIf1
24. ADD A3 2 2;
25. ADD B2 -1 A2;
26. ADD A7 1 5;
27. MLZ -1 A3 A5;
28. MLZ -1 A7 4;
29. ADD A3 2 5;
30. ADD A4 2 6;
31. MLZ -1 B5 A6;
32. MLZ -1 A4 3;
33. MLZ -1 36 A3;
34. MLZ -1 14 0;
35. ADD A3 4 7; call3_fib
36. ADD A3 3 2;
37. ADD A7 3 4;
38. MLZ -1 B4 A2;
39. ADD A3 2 2;
40. ADD B2 -1 A2;
41. ADD A7 1 5;
42. MLZ -1 A3 A5;
43. MLZ -1 A7 4;
44. ADD A3 2 5;
45. ADD A4 2 6;
46. MLZ -1 B5 A6;
47. MLZ -1 A4 3;
48. MLZ -1 51 A3;
49. MLZ -1 14 0;
50. ADD A3 4 7; call2_fib
51. ADD A3 3 2;
52. ADD A7 3 4;
53. ADD B4 B2 A2;
54. MLZ -1 A3 7;
55. ADD A3 1 2;
56. MLZ -1 B3 0;
57. MLZ -1 B2 3; endSub0_fib

RAM map:
0: pc
1: display
2: scratch0
3: fib
4: scratch1
5: scratch2
6: scratch3
7: call

fib map:
0: return
1: previous_call
2: cur
3: sum
